{"ast":null,"code":"/**\r\n * KMEANS clustering\r\n *\r\n * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>\r\n * @copyright MIT\r\n */\n\n/**\r\n * KMEANS class constructor\r\n * @constructor\r\n *\r\n * @param {Array} dataset\r\n * @param {number} k - number of clusters\r\n * @param {function} distance - distance function\r\n * @returns {KMEANS}\r\n */\nfunction KMEANS(dataset, k, distance) {\n  this.k = 3; // number of clusters\n\n  this.dataset = []; // set of feature vectors\n\n  this.assignments = []; // set of associated clusters for each feature vector\n\n  this.centroids = []; // vectors for our clusters\n\n  this.init(dataset, k, distance);\n}\n/**\r\n * @returns {undefined}\r\n */\n\n\nKMEANS.prototype.init = function (dataset, k, distance) {\n  this.assignments = [];\n  this.centroids = [];\n\n  if (typeof dataset !== 'undefined') {\n    this.dataset = dataset;\n  }\n\n  if (typeof k !== 'undefined') {\n    this.k = k;\n  }\n\n  if (typeof distance !== 'undefined') {\n    this.distance = distance;\n  }\n};\n/**\r\n * @returns {undefined}\r\n */\n\n\nKMEANS.prototype.run = function (dataset, k) {\n  this.init(dataset, k);\n  var len = this.dataset.length; // initialize centroids\n\n  for (var i = 0; i < this.k; i++) {\n    this.centroids[i] = this.randomCentroid();\n  }\n\n  var change = true;\n\n  while (change) {\n    // assign feature vectors to clusters\n    change = this.assign(); // adjust location of centroids\n\n    for (var centroidId = 0; centroidId < this.k; centroidId++) {\n      var mean = new Array(maxDim);\n      var count = 0; // init mean vector\n\n      for (var dim = 0; dim < maxDim; dim++) {\n        mean[dim] = 0;\n      }\n\n      for (var j = 0; j < len; j++) {\n        var maxDim = this.dataset[j].length; // if current cluster id is assigned to point\n\n        if (centroidId === this.assignments[j]) {\n          for (var dim = 0; dim < maxDim; dim++) {\n            mean[dim] += this.dataset[j][dim];\n          }\n\n          count++;\n        }\n      }\n\n      if (count > 0) {\n        // if cluster contain points, adjust centroid position\n        for (var dim = 0; dim < maxDim; dim++) {\n          mean[dim] /= count;\n        }\n\n        this.centroids[centroidId] = mean;\n      } else {\n        // if cluster is empty, generate new random centroid\n        this.centroids[centroidId] = this.randomCentroid();\n        change = true;\n      }\n    }\n  }\n\n  return this.getClusters();\n};\n/**\r\n * Generate random centroid\r\n *\r\n * @returns {Array}\r\n */\n\n\nKMEANS.prototype.randomCentroid = function () {\n  var maxId = this.dataset.length - 1;\n  var centroid;\n  var id;\n\n  do {\n    id = Math.round(Math.random() * maxId);\n    centroid = this.dataset[id];\n  } while (this.centroids.indexOf(centroid) >= 0);\n\n  return centroid;\n};\n/**\r\n * Assign points to clusters\r\n *\r\n * @returns {boolean}\r\n */\n\n\nKMEANS.prototype.assign = function () {\n  var change = false;\n  var len = this.dataset.length;\n  var closestCentroid;\n\n  for (var i = 0; i < len; i++) {\n    closestCentroid = this.argmin(this.dataset[i], this.centroids, this.distance);\n\n    if (closestCentroid != this.assignments[i]) {\n      this.assignments[i] = closestCentroid;\n      change = true;\n    }\n  }\n\n  return change;\n};\n/**\r\n * Extract information about clusters\r\n *\r\n * @returns {undefined}\r\n */\n\n\nKMEANS.prototype.getClusters = function () {\n  var clusters = new Array(this.k);\n  var centroidId;\n\n  for (var pointId = 0; pointId < this.assignments.length; pointId++) {\n    centroidId = this.assignments[pointId]; // init empty cluster\n\n    if (typeof clusters[centroidId] === 'undefined') {\n      clusters[centroidId] = [];\n    }\n\n    clusters[centroidId].push(pointId);\n  }\n\n  return clusters;\n}; // utils\n\n/**\r\n * @params {Array} point\r\n * @params {Array.<Array>} set\r\n * @params {Function} f\r\n * @returns {number}\r\n */\n\n\nKMEANS.prototype.argmin = function (point, set, f) {\n  var min = Number.MAX_VALUE;\n  var arg = 0;\n  var len = set.length;\n  var d;\n\n  for (var i = 0; i < len; i++) {\n    d = f(point, set[i]);\n\n    if (d < min) {\n      min = d;\n      arg = i;\n    }\n  }\n\n  return arg;\n};\n/**\r\n * Euclidean distance\r\n *\r\n * @params {number} p\r\n * @params {number} q\r\n * @returns {number}\r\n */\n\n\nKMEANS.prototype.distance = function (p, q) {\n  var sum = 0;\n  var i = Math.min(p.length, q.length);\n\n  while (i--) {\n    var diff = p[i] - q[i];\n    sum += diff * diff;\n  }\n\n  return Math.sqrt(sum);\n};\n\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = KMEANS;\n}","map":null,"metadata":{},"sourceType":"script"}