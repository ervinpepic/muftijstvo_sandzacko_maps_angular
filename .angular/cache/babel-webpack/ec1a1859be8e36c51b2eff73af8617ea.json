{"ast":null,"code":"import clone from \"@turf/clone\";\nimport { coordAll, featureEach } from \"@turf/meta\";\nimport skmeans from \"skmeans\";\n/**\n * Takes a set of {@link Point|points} and partition them into clusters using the k-mean .\n * It uses the [k-means algorithm](https://en.wikipedia.org/wiki/K-means_clustering)\n *\n * @name clustersKmeans\n * @param {FeatureCollection<Point>} points to be clustered\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.numberOfClusters=Math.sqrt(numberOfPoints/2)] numberOfClusters that will be generated\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {FeatureCollection<Point>} Clustered Points with an additional two properties associated to each Feature:\n * - {number} cluster - the associated clusterId\n * - {[number, number]} centroid - Centroid of the cluster [Longitude, Latitude]\n * @example\n * // create random points with random z-values in their properties\n * var points = turf.randomPoint(100, {bbox: [0, 30, 20, 50]});\n * var options = {numberOfClusters: 7};\n * var clustered = turf.clustersKmeans(points, options);\n *\n * //addToMap\n * var addToMap = [clustered];\n */\n\nfunction clustersKmeans(points, options) {\n  if (options === void 0) {\n    options = {};\n  } // Default Params\n\n\n  var count = points.features.length;\n  options.numberOfClusters = options.numberOfClusters || Math.round(Math.sqrt(count / 2)); // numberOfClusters can't be greater than the number of points\n  // fallbacks to count\n\n  if (options.numberOfClusters > count) options.numberOfClusters = count; // Clone points to prevent any mutations (enabled by default)\n\n  if (options.mutate !== true) points = clone(points); // collect points coordinates\n\n  var data = coordAll(points); // create seed to avoid skmeans to drift\n\n  var initialCentroids = data.slice(0, options.numberOfClusters); // create skmeans clusters\n\n  var skmeansResult = skmeans(data, options.numberOfClusters, initialCentroids); // store centroids {clusterId: [number, number]}\n\n  var centroids = {};\n  skmeansResult.centroids.forEach(function (coord, idx) {\n    centroids[idx] = coord;\n  }); // add associated cluster number\n\n  featureEach(points, function (point, index) {\n    var clusterId = skmeansResult.idxs[index];\n    point.properties.cluster = clusterId;\n    point.properties.centroid = centroids[clusterId];\n  });\n  return points;\n}\n\nexport default clustersKmeans;","map":null,"metadata":{},"sourceType":"module"}