{"ast":null,"code":"/**\r\n * DBSCAN - Density based clustering\r\n *\r\n * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>\r\n * @copyright MIT\r\n */\n\n/**\r\n * DBSCAN class construcotr\r\n * @constructor\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distanceFunction\r\n * @returns {DBSCAN}\r\n */\nfunction DBSCAN(dataset, epsilon, minPts, distanceFunction) {\n  /** @type {Array} */\n  this.dataset = [];\n  /** @type {number} */\n\n  this.epsilon = 1;\n  /** @type {number} */\n\n  this.minPts = 2;\n  /** @type {function} */\n\n  this.distance = this._euclideanDistance;\n  /** @type {Array} */\n\n  this.clusters = [];\n  /** @type {Array} */\n\n  this.noise = []; // temporary variables used during computation\n\n  /** @type {Array} */\n\n  this._visited = [];\n  /** @type {Array} */\n\n  this._assigned = [];\n  /** @type {number} */\n\n  this._datasetLength = 0;\n\n  this._init(dataset, epsilon, minPts, distanceFunction);\n}\n\n;\n/******************************************************************************/\n// public functions\n\n/**\r\n * Start clustering\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distanceFunction\r\n * @returns {undefined}\r\n * @access public\r\n */\n\nDBSCAN.prototype.run = function (dataset, epsilon, minPts, distanceFunction) {\n  this._init(dataset, epsilon, minPts, distanceFunction);\n\n  for (var pointId = 0; pointId < this._datasetLength; pointId++) {\n    // if point is not visited, check if it forms a cluster\n    if (this._visited[pointId] !== 1) {\n      this._visited[pointId] = 1; // if closest neighborhood is too small to form a cluster, mark as noise\n\n      var neighbors = this._regionQuery(pointId);\n\n      if (neighbors.length < this.minPts) {\n        this.noise.push(pointId);\n      } else {\n        // create new cluster and add point\n        var clusterId = this.clusters.length;\n        this.clusters.push([]);\n\n        this._addToCluster(pointId, clusterId);\n\n        this._expandCluster(clusterId, neighbors);\n      }\n    }\n  }\n\n  return this.clusters;\n};\n/******************************************************************************/\n// protected functions\n\n/**\r\n * Set object properties\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distance\r\n * @returns {undefined}\r\n * @access protected\r\n */\n\n\nDBSCAN.prototype._init = function (dataset, epsilon, minPts, distance) {\n  if (dataset) {\n    if (!(dataset instanceof Array)) {\n      throw Error('Dataset must be of type array, ' + typeof dataset + ' given');\n    }\n\n    this.dataset = dataset;\n    this.clusters = [];\n    this.noise = [];\n    this._datasetLength = dataset.length;\n    this._visited = new Array(this._datasetLength);\n    this._assigned = new Array(this._datasetLength);\n  }\n\n  if (epsilon) {\n    this.epsilon = epsilon;\n  }\n\n  if (minPts) {\n    this.minPts = minPts;\n  }\n\n  if (distance) {\n    this.distance = distance;\n  }\n};\n/**\r\n * Expand cluster to closest points of given neighborhood\r\n *\r\n * @param {number} clusterId\r\n * @param {Array} neighbors\r\n * @returns {undefined}\r\n * @access protected\r\n */\n\n\nDBSCAN.prototype._expandCluster = function (clusterId, neighbors) {\n  /**\r\n   * It's very important to calculate length of neighbors array each time,\r\n   * as the number of elements changes over time\r\n   */\n  for (var i = 0; i < neighbors.length; i++) {\n    var pointId2 = neighbors[i];\n\n    if (this._visited[pointId2] !== 1) {\n      this._visited[pointId2] = 1;\n\n      var neighbors2 = this._regionQuery(pointId2);\n\n      if (neighbors2.length >= this.minPts) {\n        neighbors = this._mergeArrays(neighbors, neighbors2);\n      }\n    } // add to cluster\n\n\n    if (this._assigned[pointId2] !== 1) {\n      this._addToCluster(pointId2, clusterId);\n    }\n  }\n};\n/**\r\n * Add new point to cluster\r\n *\r\n * @param {number} pointId\r\n * @param {number} clusterId\r\n */\n\n\nDBSCAN.prototype._addToCluster = function (pointId, clusterId) {\n  this.clusters[clusterId].push(pointId);\n  this._assigned[pointId] = 1;\n};\n/**\r\n * Find all neighbors around given point\r\n *\r\n * @param {number} pointId,\r\n * @param {number} epsilon\r\n * @returns {Array}\r\n * @access protected\r\n */\n\n\nDBSCAN.prototype._regionQuery = function (pointId) {\n  var neighbors = [];\n\n  for (var id = 0; id < this._datasetLength; id++) {\n    var dist = this.distance(this.dataset[pointId], this.dataset[id]);\n\n    if (dist < this.epsilon) {\n      neighbors.push(id);\n    }\n  }\n\n  return neighbors;\n};\n/******************************************************************************/\n// helpers\n\n/**\r\n * @param {Array} a\r\n * @param {Array} b\r\n * @returns {Array}\r\n * @access protected\r\n */\n\n\nDBSCAN.prototype._mergeArrays = function (a, b) {\n  var len = b.length;\n\n  for (var i = 0; i < len; i++) {\n    var P = b[i];\n\n    if (a.indexOf(P) < 0) {\n      a.push(P);\n    }\n  }\n\n  return a;\n};\n/**\r\n * Calculate euclidean distance in multidimensional space\r\n *\r\n * @param {Array} p\r\n * @param {Array} q\r\n * @returns {number}\r\n * @access protected\r\n */\n\n\nDBSCAN.prototype._euclideanDistance = function (p, q) {\n  var sum = 0;\n  var i = Math.min(p.length, q.length);\n\n  while (i--) {\n    sum += (p[i] - q[i]) * (p[i] - q[i]);\n  }\n\n  return Math.sqrt(sum);\n};\n\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = DBSCAN;\n}","map":null,"metadata":{},"sourceType":"script"}