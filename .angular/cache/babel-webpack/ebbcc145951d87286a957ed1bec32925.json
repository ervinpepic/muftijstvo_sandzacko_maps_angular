{"ast":null,"code":"\"use strict\";\n/*jshint esversion: 6 */\n\nvar Distance = require(\"./distance.js\"),\n    ClusterInit = require(\"./kinit.js\"),\n    eudist = Distance.eudist,\n    mandist = Distance.mandist,\n    dist = Distance.dist,\n    kmrand = ClusterInit.kmrand,\n    kmpp = ClusterInit.kmpp;\n\nvar MAX = 10000;\n/**\n * Inits an array with values\n */\n\nfunction init(len, val, v) {\n  v = v || [];\n\n  for (var i = 0; i < len; i++) {\n    v[i] = val;\n  }\n\n  return v;\n}\n\nfunction skmeans(data, k, initial, maxit) {\n  var ks = [],\n      old = [],\n      idxs = [],\n      dist = [];\n  var conv = false,\n      it = maxit || MAX;\n  var len = data.length,\n      vlen = data[0].length,\n      multi = vlen > 0;\n  var count = [];\n\n  if (!initial) {\n    var _idxs = {};\n\n    while (ks.length < k) {\n      var idx = Math.floor(Math.random() * len);\n\n      if (!_idxs[idx]) {\n        _idxs[idx] = true;\n        ks.push(data[idx]);\n      }\n    }\n  } else if (initial == \"kmrand\") {\n    ks = kmrand(data, k);\n  } else if (initial == \"kmpp\") {\n    ks = kmpp(data, k);\n  } else {\n    ks = initial;\n  }\n\n  do {\n    // Reset k count\n    init(k, 0, count); // For each value in data, find the nearest centroid\n\n    for (var i = 0; i < len; i++) {\n      var min = Infinity,\n          _idx = 0;\n\n      for (var j = 0; j < k; j++) {\n        // Multidimensional or unidimensional\n        var dist = multi ? eudist(data[i], ks[j]) : Math.abs(data[i] - ks[j]);\n\n        if (dist <= min) {\n          min = dist;\n          _idx = j;\n        }\n      }\n\n      idxs[i] = _idx; // Index of the selected centroid for that value\n\n      count[_idx]++; // Number of values for this centroid\n    } // Recalculate centroids\n\n\n    var sum = [],\n        old = [],\n        dif = 0;\n\n    for (var _j = 0; _j < k; _j++) {\n      // Multidimensional or unidimensional\n      sum[_j] = multi ? init(vlen, 0, sum[_j]) : 0;\n      old[_j] = ks[_j];\n    } // If multidimensional\n\n\n    if (multi) {\n      for (var _j2 = 0; _j2 < k; _j2++) {\n        ks[_j2] = [];\n      } // Sum values and count for each centroid\n\n\n      for (var _i = 0; _i < len; _i++) {\n        var _idx2 = idxs[_i],\n            // Centroid for that item\n        vsum = sum[_idx2],\n            // Sum values for this centroid\n        vect = data[_i]; // Current vector\n        // Accumulate value on the centroid for current vector\n\n        for (var h = 0; h < vlen; h++) {\n          vsum[h] += vect[h];\n        }\n      } // Calculate the average for each centroid\n\n\n      conv = true;\n\n      for (var _j3 = 0; _j3 < k; _j3++) {\n        var ksj = ks[_j3],\n            // Current centroid\n        sumj = sum[_j3],\n            // Accumulated centroid values\n        oldj = old[_j3],\n            // Old centroid value\n        cj = count[_j3]; // Number of elements for this centroid\n        // New average\n\n        for (var _h = 0; _h < vlen; _h++) {\n          ksj[_h] = sumj[_h] / cj || 0; // New centroid\n        } // Find if centroids have moved\n\n\n        if (conv) {\n          for (var _h2 = 0; _h2 < vlen; _h2++) {\n            if (oldj[_h2] != ksj[_h2]) {\n              conv = false;\n              break;\n            }\n          }\n        }\n      }\n    } // If unidimensional\n    else {\n      // Sum values and count for each centroid\n      for (var _i2 = 0; _i2 < len; _i2++) {\n        var _idx3 = idxs[_i2];\n        sum[_idx3] += data[_i2];\n      } // Calculate the average for each centroid\n\n\n      for (var _j4 = 0; _j4 < k; _j4++) {\n        ks[_j4] = sum[_j4] / count[_j4] || 0; // New centroid\n      } // Find if centroids have moved\n\n\n      conv = true;\n\n      for (var _j5 = 0; _j5 < k; _j5++) {\n        if (old[_j5] != ks[_j5]) {\n          conv = false;\n          break;\n        }\n      }\n    }\n\n    conv = conv || --it <= 0;\n  } while (!conv);\n\n  return {\n    it: MAX - it,\n    k: k,\n    idxs: idxs,\n    centroids: ks\n  };\n}\n\nmodule.exports = skmeans; //# sourceMappingURL=main.js.map","map":null,"metadata":{},"sourceType":"script"}