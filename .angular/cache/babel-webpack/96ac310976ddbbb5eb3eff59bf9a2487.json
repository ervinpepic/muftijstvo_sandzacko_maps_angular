{"ast":null,"code":"\"use strict\";\n\nvar Distance = require(\"./distance.js\"),\n    eudist = Distance.eudist,\n    dist = Distance.dist;\n\nmodule.exports = {\n  kmrand: function kmrand(data, k) {\n    var map = {},\n        ks = [],\n        t = k << 2;\n    var len = data.length;\n    var multi = data[0].length > 0;\n\n    while (ks.length < k && t-- > 0) {\n      var d = data[Math.floor(Math.random() * len)];\n      var key = multi ? d.join(\"_\") : \"\" + d;\n\n      if (!map[key]) {\n        map[key] = true;\n        ks.push(d);\n      }\n    }\n\n    if (ks.length < k) throw new Error(\"Error initializating clusters\");else return ks;\n  },\n\n  /**\n   * K-means++ initial centroid selection\n   */\n  kmpp: function kmpp(data, k) {\n    var distance = data[0].length ? eudist : dist;\n    var ks = [],\n        len = data.length;\n    var multi = data[0].length > 0;\n    var map = {}; // First random centroid\n\n    var c = data[Math.floor(Math.random() * len)];\n    var key = multi ? c.join(\"_\") : \"\" + c;\n    ks.push(c);\n    map[key] = true; // Retrieve next centroids\n\n    while (ks.length < k) {\n      // Min Distances between current centroids and data points\n      var dists = [],\n          lk = ks.length;\n      var dsum = 0,\n          prs = [];\n\n      for (var i = 0; i < len; i++) {\n        var min = Infinity;\n\n        for (var j = 0; j < lk; j++) {\n          var _dist = distance(data[i], ks[j]);\n\n          if (_dist <= min) min = _dist;\n        }\n\n        dists[i] = min;\n      } // Sum all min distances\n\n\n      for (var _i = 0; _i < len; _i++) {\n        dsum += dists[_i];\n      } // Probabilities and cummulative prob (cumsum)\n\n\n      for (var _i2 = 0; _i2 < len; _i2++) {\n        prs[_i2] = {\n          i: _i2,\n          v: data[_i2],\n          pr: dists[_i2] / dsum,\n          cs: 0\n        };\n      } // Sort Probabilities\n\n\n      prs.sort(function (a, b) {\n        return a.pr - b.pr;\n      }); // Cummulative Probabilities\n\n      prs[0].cs = prs[0].pr;\n\n      for (var _i3 = 1; _i3 < len; _i3++) {\n        prs[_i3].cs = prs[_i3 - 1].cs + prs[_i3].pr;\n      } // Randomize\n\n\n      var rnd = Math.random(); // Gets only the items whose cumsum >= rnd\n\n      var idx = 0;\n\n      while (idx < len - 1 && prs[idx++].cs < rnd) {}\n\n      ks.push(prs[idx - 1].v);\n      /*\n      let done = false;\n      while(!done) {\n      \t// this is our new centroid\n      \tc = prs[idx-1].v\n      \tkey = multi? c.join(\"_\") : `${c}`;\n      \tif(!map[key]) {\n      \t\tmap[key] = true;\n      \t\tks.push(c);\n      \t\tdone = true;\n      \t}\n      \telse {\n      \t\tidx++;\n      \t}\n      }\n      */\n    }\n\n    return ks;\n  }\n}; //# sourceMappingURL=kinit.js.map","map":null,"metadata":{},"sourceType":"script"}