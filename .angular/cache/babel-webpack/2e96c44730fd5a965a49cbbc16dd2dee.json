{"ast":null,"code":"/**\r\n * @requires ./PriorityQueue.js\r\n */\nif (typeof module !== 'undefined' && module.exports) {\n  var PriorityQueue = require('./PriorityQueue.js');\n}\n/**\r\n * OPTICS - Ordering points to identify the clustering structure\r\n *\r\n * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>\r\n * @copyright MIT\r\n */\n\n/**\r\n * OPTICS class constructor\r\n * @constructor\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distanceFunction\r\n * @returns {OPTICS}\r\n */\n\n\nfunction OPTICS(dataset, epsilon, minPts, distanceFunction) {\n  /** @type {number} */\n  this.epsilon = 1;\n  /** @type {number} */\n\n  this.minPts = 1;\n  /** @type {function} */\n\n  this.distance = this._euclideanDistance; // temporary variables used during computation\n\n  /** @type {Array} */\n\n  this._reachability = [];\n  /** @type {Array} */\n\n  this._processed = [];\n  /** @type {number} */\n\n  this._coreDistance = 0;\n  /** @type {Array} */\n\n  this._orderedList = [];\n\n  this._init(dataset, epsilon, minPts, distanceFunction);\n}\n/******************************************************************************/\n// pulic functions\n\n/**\r\n * Start clustering\r\n *\r\n * @param {Array} dataset\r\n * @returns {undefined}\r\n * @access public\r\n */\n\n\nOPTICS.prototype.run = function (dataset, epsilon, minPts, distanceFunction) {\n  this._init(dataset, epsilon, minPts, distanceFunction);\n\n  for (var pointId = 0, l = this.dataset.length; pointId < l; pointId++) {\n    if (this._processed[pointId] !== 1) {\n      this._processed[pointId] = 1;\n      this.clusters.push([pointId]);\n      var clusterId = this.clusters.length - 1;\n\n      this._orderedList.push(pointId);\n\n      var priorityQueue = new PriorityQueue(null, null, 'asc');\n\n      var neighbors = this._regionQuery(pointId); // using priority queue assign elements to new cluster\n\n\n      if (this._distanceToCore(pointId) !== undefined) {\n        this._updateQueue(pointId, neighbors, priorityQueue);\n\n        this._expandCluster(clusterId, priorityQueue);\n      }\n    }\n  }\n\n  return this.clusters;\n};\n/**\r\n * Generate reachability plot for all points\r\n *\r\n * @returns {array}\r\n * @access public\r\n */\n\n\nOPTICS.prototype.getReachabilityPlot = function () {\n  var reachabilityPlot = [];\n\n  for (var i = 0, l = this._orderedList.length; i < l; i++) {\n    var pointId = this._orderedList[i];\n    var distance = this._reachability[pointId];\n    reachabilityPlot.push([pointId, distance]);\n  }\n\n  return reachabilityPlot;\n};\n/******************************************************************************/\n// protected functions\n\n/**\r\n * Set object properties\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distance\r\n * @returns {undefined}\r\n * @access protected\r\n */\n\n\nOPTICS.prototype._init = function (dataset, epsilon, minPts, distance) {\n  if (dataset) {\n    if (!(dataset instanceof Array)) {\n      throw Error('Dataset must be of type array, ' + typeof dataset + ' given');\n    }\n\n    this.dataset = dataset;\n    this.clusters = [];\n    this._reachability = new Array(this.dataset.length);\n    this._processed = new Array(this.dataset.length);\n    this._coreDistance = 0;\n    this._orderedList = [];\n  }\n\n  if (epsilon) {\n    this.epsilon = epsilon;\n  }\n\n  if (minPts) {\n    this.minPts = minPts;\n  }\n\n  if (distance) {\n    this.distance = distance;\n  }\n};\n/**\r\n * Update information in queue\r\n *\r\n * @param {number} pointId\r\n * @param {Array} neighbors\r\n * @param {PriorityQueue} queue\r\n * @returns {undefined}\r\n * @access protected\r\n */\n\n\nOPTICS.prototype._updateQueue = function (pointId, neighbors, queue) {\n  var self = this;\n  this._coreDistance = this._distanceToCore(pointId);\n  neighbors.forEach(function (pointId2) {\n    if (self._processed[pointId2] === undefined) {\n      var dist = self.distance(self.dataset[pointId], self.dataset[pointId2]);\n      var newReachableDistance = Math.max(self._coreDistance, dist);\n\n      if (self._reachability[pointId2] === undefined) {\n        self._reachability[pointId2] = newReachableDistance;\n        queue.insert(pointId2, newReachableDistance);\n      } else {\n        if (newReachableDistance < self._reachability[pointId2]) {\n          self._reachability[pointId2] = newReachableDistance;\n          queue.remove(pointId2);\n          queue.insert(pointId2, newReachableDistance);\n        }\n      }\n    }\n  });\n};\n/**\r\n * Expand cluster\r\n *\r\n * @param {number} clusterId\r\n * @param {PriorityQueue} queue\r\n * @returns {undefined}\r\n * @access protected\r\n */\n\n\nOPTICS.prototype._expandCluster = function (clusterId, queue) {\n  var queueElements = queue.getElements();\n\n  for (var p = 0, l = queueElements.length; p < l; p++) {\n    var pointId = queueElements[p];\n\n    if (this._processed[pointId] === undefined) {\n      var neighbors = this._regionQuery(pointId);\n\n      this._processed[pointId] = 1;\n      this.clusters[clusterId].push(pointId);\n\n      this._orderedList.push(pointId);\n\n      if (this._distanceToCore(pointId) !== undefined) {\n        this._updateQueue(pointId, neighbors, queue);\n\n        this._expandCluster(clusterId, queue);\n      }\n    }\n  }\n};\n/**\r\n * Calculating distance to cluster core\r\n *\r\n * @param {number} pointId\r\n * @returns {number}\r\n * @access protected\r\n */\n\n\nOPTICS.prototype._distanceToCore = function (pointId) {\n  var l = this.epsilon;\n\n  for (var coreDistCand = 0; coreDistCand < l; coreDistCand++) {\n    var neighbors = this._regionQuery(pointId, coreDistCand);\n\n    if (neighbors.length >= this.minPts) {\n      return coreDistCand;\n    }\n  }\n\n  return;\n};\n/**\r\n * Find all neighbors around given point\r\n *\r\n * @param {number} pointId\r\n * @param {number} epsilon\r\n * @returns {Array}\r\n * @access protected\r\n */\n\n\nOPTICS.prototype._regionQuery = function (pointId, epsilon) {\n  epsilon = epsilon || this.epsilon;\n  var neighbors = [];\n\n  for (var id = 0, l = this.dataset.length; id < l; id++) {\n    if (this.distance(this.dataset[pointId], this.dataset[id]) < epsilon) {\n      neighbors.push(id);\n    }\n  }\n\n  return neighbors;\n};\n/******************************************************************************/\n// helpers\n\n/**\r\n * Calculate euclidean distance in multidimensional space\r\n *\r\n * @param {Array} p\r\n * @param {Array} q\r\n * @returns {number}\r\n * @access protected\r\n */\n\n\nOPTICS.prototype._euclideanDistance = function (p, q) {\n  var sum = 0;\n  var i = Math.min(p.length, q.length);\n\n  while (i--) {\n    sum += (p[i] - q[i]) * (p[i] - q[i]);\n  }\n\n  return Math.sqrt(sum);\n};\n\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = OPTICS;\n}","map":null,"metadata":{},"sourceType":"script"}